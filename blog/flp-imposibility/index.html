<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Language" content="en">
    <meta name="color-scheme" content="light dark">

    

    <meta name="author" content="Thanh Le">
    <meta name="description" content="Giới thiệu    FLP Impossibillity là một trong những paper quan trọng nhất về hệ thống phân tán, trong đó chỉ ra một số giới hạn mà chúng ta không thể vượt qua được. Ở đây, ba tác giả (Fischer, Lynch, Paterson) đã chỉ ra rằng trong những hệ thống phân tán không đồng bộ mà nó có thể chứa các process lỗi thì không tồn tại một thuật toán đồng thuận nào mà nó có thể đảm bảo sự kết thúc của việc thực thi.">
    <meta name="keywords" content="blog,developer,personal">

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="FLP Impossibility"/>
<meta name="twitter:description" content="Giới thiệu    FLP Impossibillity là một trong những paper quan trọng nhất về hệ thống phân tán, trong đó chỉ ra một số giới hạn mà chúng ta không thể vượt qua được. Ở đây, ba tác giả (Fischer, Lynch, Paterson) đã chỉ ra rằng trong những hệ thống phân tán không đồng bộ mà nó có thể chứa các process lỗi thì không tồn tại một thuật toán đồng thuận nào mà nó có thể đảm bảo sự kết thúc của việc thực thi."/>

    <meta property="og:title" content="FLP Impossibility" />
<meta property="og:description" content="Giới thiệu    FLP Impossibillity là một trong những paper quan trọng nhất về hệ thống phân tán, trong đó chỉ ra một số giới hạn mà chúng ta không thể vượt qua được. Ở đây, ba tác giả (Fischer, Lynch, Paterson) đã chỉ ra rằng trong những hệ thống phân tán không đồng bộ mà nó có thể chứa các process lỗi thì không tồn tại một thuật toán đồng thuận nào mà nó có thể đảm bảo sự kết thúc của việc thực thi." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://lenguyenthanh.com/blog/flp-imposibility/" /><meta property="article:section" content="blog" />
<meta property="article:published_time" content="2022-01-19T11:35:12+00:00" />
<meta property="article:modified_time" content="2022-01-19T11:35:12+00:00" />



    <title>
  FLP Impossibility · Thanh Le
</title>

    
      <link rel="canonical" href="https://lenguyenthanh.com/blog/flp-imposibility/">
    

    <link rel="preload" href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as="font" type="font/woff2" crossorigin>

    
      
      
      <link rel="stylesheet" href="/css/coder.min.d9fddbffe6f27e69985dc5fe0471cdb0e57fbf4775714bc3d847accb08f4a1f6.css" integrity="sha256-2f3b/&#43;byfmmYXcX&#43;BHHNsOV/v0d1cUvD2Eesywj0ofY=" crossorigin="anonymous" media="screen" />
    

    

    

    

    

    <link rel="icon" type="image/png" href="/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/images/favicon-16x16.png" sizes="16x16">

    <link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

    <meta name="generator" content="Hugo 0.92.0" />
  </head>

  
  
  <body class="preload-transitions colorscheme-light">
    
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="/">
      Thanh Le
    </a>
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link" href="/blog">Blog</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/about">About</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


      <div class="content">
        
  <section class="container page">
  <article>
    <header>
      <h1 class="title">
        <a class="title-link" href="https://lenguyenthanh.com/blog/flp-imposibility/">
          FLP Impossibility
        </a>
      </h1>
    </header>

    <h2 id="giới-thiệu">
  Giới thiệu
  <a class="heading-link" href="#gi%e1%bb%9bi-thi%e1%bb%87u">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p><a href="https://groups.csail.mit.edu/tds/papers/Lynch/jacm85.pdf">FLP Impossibillity</a> là một trong những paper quan trọng nhất về hệ thống phân tán, trong đó chỉ ra một số giới hạn mà chúng ta không thể vượt qua được. Ở đây, ba tác giả (Fischer, Lynch, Paterson) đã chỉ ra rằng trong những hệ thống phân tán không đồng bộ mà nó có thể chứa các process lỗi thì không tồn tại một thuật toán đồng thuận nào mà nó có thể đảm bảo sự kết thúc của việc thực thi.</p>
<p>Bài viết này sẽ trình bày lại chứng minh được đưa ra trong paper trên. Bài viết này sẽ được chia thành năm phần:</p>
<ul>
<li>Định nghĩa về Consensus</li>
<li>Phát biểu bài toán (System Model)</li>
<li>Biểu diễn bài toán bằng toán học (Formal Model)</li>
<li>Nêu lên mệnh đề được đưa ra trong paper</li>
<li>Trình bày chứng minh</li>
</ul>
<h2 id="định-nghĩa">
  Định nghĩa
  <a class="heading-link" href="#%c4%91%e1%bb%8bnh-ngh%c4%a9a">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>Chúng ta sẽ bắt đầu bằng một số định nghĩa cần biết về Consensus cũng như Asynchronous Model.</p>
<h3 id="consensus">
  Consensus
  <a class="heading-link" href="#consensus">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<p>Các thuật toán Consensus được dùng để giải quyết bài toán đồng thuận trên hệ thống phân tán. Một thuật toán Consensus được coi là hợp lệ nếu thoả mãn ba điều kiện sau đây:</p>
<ul>
<li><strong>Termination</strong>: Tất cả các process bình thường đều sẽ đưa ra quyết định trên một giá trị.</li>
<li><strong>Agreement</strong>: Tất cả những process đưa ra quyết định đều quyết định cùng một giá trị.</li>
<li><strong>Validity</strong>: Giá trị được đồng thuận phải được đề nghị từ một trong các process trong hệ thống.</li>
</ul>
<p>Chúng ta mặc định rằng: Thuật toán Consensus chỉ chính xác khi số lượng process bị lỗi sẽ ít hơn một hằng số được định trước.</p>
<h3 id="asynchronous-model">
  Asynchronous Model
  <a class="heading-link" href="#asynchronous-model">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<p>Asynchronous là một trong ba giả định về sự đồng bộ (Synchrony) trong hệ thống phân tán (hai giả định còn lại là Synchronous và Partially Synchronous). Với Asynchronous Model, chúng ta sẽ có những tính chất sau:</p>
<ul>
<li>Không xác định được tốc độ xử lý của các process</li>
<li>Message có thể bị deliver trễ với thời gian không xác định</li>
<li>Không có sử dụng synchronized clocks</li>
<li>Không thể sử dụng các thuật toán dựa vào time out</li>
<li>Không thể xác định được một process bị lỗi hay nó đang xử lý rất chậm</li>
</ul>
<p>Giả định về Asynchronous Model là một giả định quan trọng khi phát biểu về bài toán.</p>
<h2 id="system-model">
  System Model
  <a class="heading-link" href="#system-model">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>Khi thiết kế một thuật toán về Distributed System thì <code>System Model</code> là tập hợp các điều kiện cần để thuật toán đó có thể hoạt động một cách chính xác.</p>
<p>Paper này sẽ chứng minh rằng không tồn tại thuật toán Consensus với những điều kiện sau:</p>
<ul>
<li>Asynchronos Model</li>
<li>Chỉ cần duy nhất một process bị lỗi
<ul>
<li>Ở đây chúng ta chỉ xem xét về lỗi Crash-Stop failure - trường hợp lỗi đơn giản nhất. Do đó với những mô hình lỗi phức tạp hơn thì chúng ta sẽ có cùng kết quả.</li>
</ul>
</li>
<li>Messages System là đáng tin cậy
<ul>
<li>Tất cả các message đều được deliver đến các Non-Faulty process một và chỉ một lần.</li>
</ul>
</li>
<li>Consensus:
<ul>
<li>Đồng thuận trên tập giá trị 0, 1</li>
<li>Chỉ cần một số process đồng thuận trên cùng 1 giá trị (Partially Correct)</li>
</ul>
</li>
</ul>
<p>Có thể thấy những điều kiện trên sẽ yếu hơn so với các điều kiện thông thường trên các hệ thống phân tán (trừ Asynchronous Model). Do đó, nếu chúng ta chứng minh được rằng không tồn tại thuật toán Concensus trong trường hợp này thì thuật toán Consensus cũng không thể tồn tại với các trường hợp tổng quát hơn.</p>
<h2 id="formal-model">
  Formal Model
  <a class="heading-link" href="#formal-model">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>Trong phần này, chúng ta sẽ biểu diễn hệ thống được định nghĩa ở trên dưới dạng toán học và nêu ra kết luận về tính bất khả của bài toán.</p>
<h3 id="consensus-protocol">
  Consensus Protocol
  <a class="heading-link" href="#consensus-protocol">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<p>Gọi Consensus Protocol <code>P</code> là một hệ thống phân tán bất đồng bộ (Asynchronous Model) bao gồm N process (<code>N &gt;= 2</code>). Các process có thể trao đổi thông tin bằng cách gửi <code>Message</code> cho nhau thông qua một <code>Message System</code>. Các thành phần đó sẽ được định nghĩa như bên dưới.</p>
<h3 id="process">
  Process
  <a class="heading-link" href="#process">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<p>Mỗi một process sẽ có những thành phần như sau:</p>
<ul>
<li>Một Input Register $x_p$ sẽ có giá trị thuộc tập <code>{0, 1}</code>.</li>
<li>Một Output Register $y_p$ sẽ có giá trị thuộc tập <code>{b, 0, 1}</code>.
<ul>
<li>Giá trị khởi tạo của $y_p$ luôn là b, nghĩa là process chưa đưa ra quyết định.</li>
<li>Chỉ có thể thay đổi 1 lần  duy nhất, nghĩa là process chỉ có thể đưa ra quyết định 1 lần duy nhất.</li>
</ul>
</li>
<li>Một bộ nhớ trong vô hạn.</li>
<li>Một thuật toán Consensus, hay còn gọi là Transistion Function(TF).
<ul>
<li>TF là một deterministic function (cùng input sẽ có cùng output).</li>
</ul>
</li>
</ul>
<p>Tất cả những thành phần kể trên sẽ được gọi là <code>Internal State</code> của một process. <code>Initial State</code> là State ban đầu của một process với tất cả giá trị của các thành phần kể trên (không tính <code>Input Register</code>) đều được cho sẵn. State khi mà giá trị của $y_p$ được gán bằng <code>0</code> hoặc <code>1</code> sẽ được gọi là <code>Decision State.</code></p>
<h3 id="message-system">
  Message System
  <a class="heading-link" href="#message-system">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<p>Các process có thể trao đổi thông tin qua một <code>Message System</code> bao gồm những thành phần sau:</p>
<h4 id="message">
  Message
  <a class="heading-link" href="#message">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<p>Một <code>Message</code> là một cặp <code>(p, m)</code>, trong đó:</p>
<ul>
<li><code>p</code> là địa chỉ đến process <code>p</code></li>
<li><code>m</code> là nội dung của <code>Message</code></li>
</ul>
<p>Chúng ta gọi tập <code>M</code> là tập hợp của tất cả các <code>Message</code>.</p>
<h4 id="message-buffer">
  Message Buffer
  <a class="heading-link" href="#message-buffer">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<p>Tất cả các message (đã gửi nhưng chưa được nhận) sẽ được lưu trữ trong một cơ sở dữ liệu tên là <code>Multiset</code> được gọi là <code>Message Buffer(MB)</code>.</p>
<p><code>Multiset</code> sẽ khác với <code>Set</code> thông thường ở một điểm đó là nó có thể lưu nhiều phần tử có giá trị giống nhau.</p>
<p>Sau đây là Pseudocode ví dụ về cách mà <code>Multiset</code> hoạt động:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">val ms = Multiset&lt;Int&gt;() // {} -- bắt đầu với tập rỗng
ms.add(1) // {(1, 1)} -- phần tử 1 có mặt một lần
ms.add(1) // {(1, 2)} -- phần tử 1 có mặt hai lần
ms.remove(1) // {(1, 1)} -- phần tử 1 có mặt một lần
ms.remove(1) // {(} -- trở về với tập rỗng
</code></pre></div><p><code>Message Buffer</code> có hỗ trợ hai hàm sau:</p>
<ul>
<li><code>send(p, m)</code>: thêm <code>(p, m)</code> vào <code>MB</code> - luôn luôn thành công.</li>
<li><code>receive(p)</code>: Dùng cho các process nhận message từ <code>MB</code>. Có hai trường hợp có thể xảy ra khi một process gọi hàm này:
<ul>
<li>Trong trường hợp tồn tại một cặp <code>(p, m)</code> trong <code>MB</code> thì hàm này hoặc trả về một cặp <code>(p, m)</code> sau đó xoá <code>(p, m)</code> khỏi <code>MB</code> hoặc trả về $\phi$ - giá trị null - một cách ngẫu nhiên.</li>
<li>Nếu p không có message nào trong <code>MB</code> thì trả về $\phi$.</li>
</ul>
</li>
</ul>
<p>Hàm <code>receive</code> thoả mãn những điều kiện sau đây:</p>
<ul>
<li>Nó có thể trả $\phi$ hữu hạn nhưng không xác định lần.</li>
<li>Nếu một process <code>p</code> thực hiện <code>receive(p)</code> vô hạn lần thì nó sẽ (eventually) nhận được toàn bộ message được gửi cho nó.</li>
</ul>
<p>Ta có thể thấy <code>MB</code> này mô phỏng tính chất của <code>Asynchronous Model</code> (tính non-deterministic). Các message có thể bị chậm với một thời gian không xác định trước, nhưng nó sẽ dần dần được deliver (với điều kiện là các process gọi hàm <code>receive</code> vô hạn lần).</p>
<h3 id="configuration">
  Configuration
  <a class="heading-link" href="#configuration">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<p>Một <code>Configuration (C)</code> của hệ thống bao gồm:</p>
<ul>
<li><code>Internal State</code> của tất cả process</li>
<li>Toàn bộ message trong <code>Message Buffer</code></li>
</ul>
<p><code>Initial Configuration (IC)</code> bao gồm:</p>
<ul>
<li><code>Initial State</code> của tất cả process</li>
<li><code>Message Buffer</code> là tập rỗng</li>
</ul>
<h3 id="step">
  Step
  <a class="heading-link" href="#step">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<p><code>Step</code> là sự thay đổi của <code>Configuration</code> trong hệ thống với việc một process <code>p</code> thực hiện những bước như sau:</p>
<ol>
<li>p thực thi hàm receive
<ul>
<li>$(m, MB') = MB.receive(p)$ Với</li>
<li>$m \in M \cup \phi$</li>
<li>$MB' = MB \setminus m$</li>
</ul>
</li>
<li>Cho <code>e = (p, m)</code> thì e sẽ được gọi là một <code>Event</code></li>
<li>Sử dụng Transistion Function để apply event <code>e</code> vào <code>p</code>:
<ul>
<li>$(p_I', MS) = e(p) = TF(e, p_I)$</li>
<li>$p_I'$ là state mới của p sau khi apply <code>e(p)</code></li>
<li><code>MS</code> là một tập Message mới mà p muốn gửi tới <code>MB</code> khi apply <code>e(p)</code></li>
</ul>
</li>
<li>Gửi message đến <code>Message Buffer</code>: $MB'' = MB' \cup MS$</li>
<li>Configuration mới: $C' = C(p_I', MB'')$</li>
</ol>
<p>Vì <code>TF</code> là một Deterministic Function nên với mỗi <code>Configuraton</code>, kết quả của mỗi <code>Step</code> sẽ phụ thuộc hoàn toàn vào Event <code>e=(p,m)</code>.</p>
<p>Hay <code>step: C' = e(C)</code></p>
<h4 id="faultynon-faulty-process">
  Faulty/Non-faulty Process
  <a class="heading-link" href="#faultynon-faulty-process">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<p>Một process <code>p</code> được coi là hoạt động bình thường (non-faulty) khi nó thực thi <code>step</code> vô hạn lần. Nếu ngược lại thì sẽ được coi là lỗi (faulty). Tương đương với việc gọi <code>receive(p)</code> vô hạn lần.</p>
<h3 id="schedule">
  Schedule
  <a class="heading-link" href="#schedule">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<p>Một <code>Schedule</code> từ <code>C</code> là một chuỗi hữu hạn/vô hạn event $\sigma$ mà chúng có thể apply từng <code>Event</code> lần lượt, bắt đầu từ <code>C</code>.</p>
<ul>
<li>$\sigma = {e_1, e_2, \cdots, e_n}$</li>
<li>$\sigma(C) = e_n(\cdots, e_2(e_1(C))$</li>
</ul>
<p>Tất cả các bước apply $\sigma$ vào <code>C</code> thì được gọi là <code>Run</code>.</p>
<p>Một Configuration <code>C1</code> được gọi là <code>reachable</code> từ <code>C</code> nếu tồn tại một chuỗi hữu hạn $\sigma$ thoả mãn: $C1 = \sigma(C)$.</p>
<p>Một Configuration có thể <code>reachable</code> từ một Initial Configuration thì được gọi là <code>accessible</code>.</p>
<p>Từ nay về sau, các Configuration được nhắc đến đều được hiểu là một <code>accessible</code> Configuration.</p>
<h4 id="một-số-khái-niệm-khác-về-run">
  Một số khái niệm khác về <code>Run</code>
  <a class="heading-link" href="#m%e1%bb%99t-s%e1%bb%91-kh%c3%a1i-ni%e1%bb%87m-kh%c3%a1c-v%e1%bb%81-run">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<p>Một Configuration C có <code>Decision Value</code> khi tồn tại ít nhất một process p ở <code>Decision State</code> hay $y_p = v; v \in {0, 1}$.</p>
<p><code>Run</code> được gọi là <code>admissible</code> nếu nó có tối đa một process lỗi và toàn bộ mesage được gửi tới các non-faulty process đều được nhận.</p>
<p><code>Run</code> được gọi là <code>deciding Run</code> khi tồn tại ít nhất một process đạt <code>Decision State</code>.</p>
<h4 id="tính-chính-xác-của-consensus-protocol">
  Tính chính xác của Consensus Protocol
  <a class="heading-link" href="#t%c3%adnh-ch%c3%adnh-x%c3%a1c-c%e1%bb%a7a-consensus-protocol">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<p>Consensus Protocol <code>P</code> được coi là <code>đúng một phần (partial correct)</code> nếu:</p>
<ul>
<li>Không tồn tại <code>accessible Configuration</code> nào có nhiều hơn một <code>Decision Value</code> (tính Agreement).</li>
<li>$\forall v \in {0, 1} \exists$ accessible Configuration C mà <code>Decision Value</code> của C sẽ bằng <code>v</code>.</li>
</ul>
<p>Consensus Protocol <code>P</code> được coi là <code>đúng (totally correct)</code> nếu nó <code>partial correct</code> và tất mọi <code>admissible Run</code> đều là <code>deciding Run</code>.</p>
<h2 id="mệnh-đề">
  Mệnh đề
  <a class="heading-link" href="#m%e1%bb%87nh-%c4%91%e1%bb%81">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p><strong>Không tồn tại Consensus Protocol mà <code>totally correct</code> trong điều kiện có ít nhất một faulty process.</strong></p>
<p>Chúng ta sẽ chứng minh mệnh đề này bằng phương pháp phản chứng. Giả sử tồn tại một Consensus Protocol <code>P</code> thoả mãn mệnh đề, chúng ta sẽ chỉ ra tồn tại hoạt cảnh mà <code>P</code> sẽ không bao giờ có thể đưa ra một đồng thuận về kết quả cuối cùng, từ đó <code>P</code> sẽ vi phạm tính chất Termination.</p>
<h2 id="chứng-minh">
  Chứng minh
  <a class="heading-link" href="#ch%e1%bb%a9ng-minh">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>Ta sẽ chứng minh bài toán bằng phản chứng. Nhưng trước khi đi vào chứng minh, chúng ta sẽ nêu lên ba bổ đề mà chúng ta sẽ sử dụng trong chứng minh.</p>
<h3 id="bổ-đề-1---tính-giao-hoán-của-schedule">
  Bổ đề 1 - Tính giao hoán của Schedule
  <a class="heading-link" href="#b%e1%bb%95-%c4%91%e1%bb%81-1---t%c3%adnh-giao-ho%c3%a1n-c%e1%bb%a7a-schedule">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<p><strong>Cho một Configuration C, 2 scheduler $\sigma_1, \sigma_2$; gọi $C_1 = \sigma_1(C)$, $C_2 = \sigma_2(C)$. Nếu tập hợp các process trong $\sigma_1$ và $\sigma_2$ không giao nhau, thì chúng ta có thể apply $\sigma_1$ cho $C_2$, apply $\sigma_2$ cho $C_1$ và cả 2 đều cho ra cùng một Configuration $C_3$ hay $C_3 = \sigma_2(\sigma_1(C)) = \sigma_1(\sigma_2(C))$</strong></p>
<p><img src="https://i.imgur.com/fH7O7ED.png" alt=""></p>
<h4 id="chứng-minh-1">
  Chứng minh
  <a class="heading-link" href="#ch%e1%bb%a9ng-minh-1">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<p>Đầu tiên ta thấy nếu một event $e \notin \sigma_1$ có thể apply vào <code>C</code> thì nó có thể apply vào $C_1$ (vì mỗi message có thể bị trễ một cách bất kỳ). Do đó, chúng ta có thể apply $\sigma_2$ vào $C_1$. Tương tự cho việc apply $\sigma_1$ vào $C_2$.</p>
<p>Gọi $p(\sigma)$ là tập các process liên quan đến một Schedule $\sigma$. Theo đề bài, ta có $p(\sigma_1) \cup p(sigma_2) = \emptyset$.</p>
<p>Do $\sigma_1$ và $\sigma_2$ chỉ thay đổi State của 2 tập process khác nhau trong C nên việc thay đổi thứ tự apply giữa $\sigma_1$ và $\sigma_2$ sẽ không thay đổi <code>Internal State</code> của các process. (1)</p>
<p>Ngoài ra <code>Message Buffer</code> có tính giao hoán (tính chất của <code>Multiset</code>). Nên việc thay đổi thứ tự gửi các message (từ việc apply $\sigma_1$ và $\sigma_2$) sẽ không thay đổi kết quả cuối cùng của <code>MB</code>. (2)</p>
<p>Từ (1) và (2) ta có dpcm.</p>
<h3 id="bổ-đề-2">
  Bổ đề 2
  <a class="heading-link" href="#b%e1%bb%95-%c4%91%e1%bb%81-2">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<p>Cho một Configuration C, gọi <code>V</code> là tập hợp của các <code>Decision Value</code> của tất cả các <code>reachable Configuraton</code> từ C. C được gọi là <code>Bivalent</code> nếu <code>|V| = 2</code>. C được gọi là <code>Univalent</code> nếu <code>|V| = 1</code>, hay còn được gọi là <code>0-valent</code> hoặc <code>1-valent</code> tuỳ thuộc vào giá trị của <code>Decision Value</code> là 0 hay 1.</p>
<p>Bởi vì P là <code>totally correct</code> nên <code>|V| != 0</code>.</p>
<h4 id="nội-dung">
  Nội dung
  <a class="heading-link" href="#n%e1%bb%99i-dung">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<p><strong>P luôn luôn có một <code>Initial Configuration</code> là <code>Bivalent</code></strong></p>
<h4 id="chứng-minh-2">
  Chứng minh
  <a class="heading-link" href="#ch%e1%bb%a9ng-minh-2">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<p>Giả sử <code>P</code> không có một <code>Initial Configuration</code> nào là <code>Bivalent</code>.</p>
<p>Ta gọi hai configuration $C_1$, $C_2$ là <code>kề nhau(adjcent)</code> nếu tất cả giá trị $x_p$ của chúng chỉ khác nhau ở một process <code>p</code>.</p>
<p>Ta thấy, với mọi $C_0$, $C_n$ bất kỳ, tồn tại chuỗi: $[C_0, C_1, \cdots, C_n]$ thoả mãn: $C_i$ và $C_i+1$ là 2 process kề nhau (*).</p>
<p>Do định nghĩa về <code>partial correct</code>, <code>P</code> phải có <code>0-valent</code> và <code>1-valent</code>. Chọn $C_0$ và $C_n$ sao cho $C_0$ là <code>0-valent</code> và $C_n$ là <code>1-valent</code>. Từ (*) ta thấy, tồn tại hai process kề nhau $C_0$, $C_1$ mà $C_0$ là <code>0-valent</code> và $C_1$ là <code>1-valent</code>.</p>
<p>Giả sử <code>p</code> là process duy nhất mà $C_0$, $C_1$ có thể phân biệt được. Bây giờ chọn một <code>amissible run</code> $\sigma$ bất kỳ bắt nguồn từ $C_0$ mà <code>p</code> sẽ không tham gia vào. Khi đó, chúng ta cũng có thể apply $\sigma$ cho $C_1$.</p>
<p>Ta thấy, $\sigma(C_0) = \sigma(C_1)$ vì toàn bộ <code>Intial State</code> của $C_0$, $C_1$ là giống nhau (trừ <code>p</code>) và <code>p</code> sẽ không được sử dụng với $\sigma$.</p>
<p>Chú ý: <code>P</code> là <code>totally correct</code> khi mọi <code>admissible run</code> là <code>deciding run</code>. Vì vậy, <code>Decision Value</code> của $\sigma(C_0)$ và $\sigma(C_1)$ phải giống nhau trái ngược với giả thiết đưa ra là  $C_0$ là <code>0-valent</code> và $C_1$ là <code>1-valent</code> dpcm.</p>
<h3 id="bổ-đề-3">
  Bổ đề 3
  <a class="heading-link" href="#b%e1%bb%95-%c4%91%e1%bb%81-3">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<p><strong>Cho <code>C</code> là một <code>Bivalent</code> Configuration của <code>P</code>, <code>e=(p,m)</code> là một <code>Event</code> mà nó có thể apply cho <code>C</code>. Gọi <code>T</code> là tập hợp các Configuratioin có thể <code>reachable</code> từ C mà không apply <code>e</code>, và D= e(T) = {$e(E) | E \in T$ và e có thể apply cho E}. Chứng minh rằng D có chứa một <code>Bivalent Configuration</code>.</strong></p>
<p>Hay nói một cách đơn giản hơn, cho <code>C</code> là một <code>Bivalent</code> Configuration, <code>e=(p,m)</code> là một <code>Event</code> mà nó có thể apply cho <code>C</code>. Tồn tại một <code>reachable</code> Configuration <code>C'</code> từ <code>C</code> thoả mãn 2 điều kiện: <code>C'</code> là <code>Bivalent</code> và <code>e</code> là Event cuối cùng được apply trước khi có <code>C'</code>.</p>
<h4 id="chứng-minh-3">
  Chứng minh
  <a class="heading-link" href="#ch%e1%bb%a9ng-minh-3">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<p>Vì message có thể bị trễ với thời gian không xác định trước (nhưng hữu hạn) nên nếu <code>e</code> có thể apply cho <code>C</code>, thì e cũng có thể apply cho <code>C'</code> $\forall C' \in T$.</p>
<p>Giả sử D chỉ có <code>Univalent</code> Configuration.</p>
<p>Gọi $E_i$ là một <code>i-valent</code> reachable Configuration từ C, $i \in {0,1}$. Do C là <code>Bivalent</code> nên sẽ tồn tại $E_i$ với $i \in {0,1}$.</p>
<p>Với mỗi $E_i$, có 2 trường hợp có thể xảy ra:</p>
<ul>
<li>$E_i \in T$, ta có $F_i = e(E_i) \in D$</li>
<li>$E_i \notin T$, ta có e đã được apply trước khi đạt được $E_i$. Do đó, $\exists F_i \in D$ mà $E_i$ có thể <code>reachable</code> từ $F_i$.</li>
</ul>
<p>Chính vì vậy, trong bất cứ trường hợp nào ta cũng sẽ có:</p>
<ul>
<li>$F_i$ là không phải là <code>Bivalen</code> vì $F_i \in D$.</li>
<li>Một trong $F_i$ và $E_i$ có thể <code>reachable</code> từ cái còn lại.</li>
</ul>
<p>Từ đó, ta thấy D sẽ chứa cả <code>0-valent</code> và <code>1-valent</code>.</p>
<p>Gọi hai Configuration $C_1$ và $C_2$ là hàng xóm (neighbors) của nhau nếu một trong hai là kết của của cái còn lại bằng một <code>Step</code> duy nhất. Hay $\exists e | e(C_1) = C_2 \lor e(C_2) = C_1$.</p>
<p>Dễ thấy tồn tại hai hàng xóm $C_0$ và $C_1$ thoả mãn: $D_i=e(C_i)$ là <code>i-valent</code>,  $i \in {0,1}$.</p>
<p>Không mất tính tổng quát, có thể giả sử $C_1 = e'(C_0)$ với <code>e'=(p', m')</code>.</p>
<p>Ở đây cũng có hai trường hợp có thể xảy ra, <code>p = p'</code> và <code>p != p'</code>.</p>
<p><strong>Trường hợp 1</strong>: Nếu <code>p != p'</code></p>
<p>Theo mệnh đề 1 ta có: $D_1 = e(C_1) = e(e'(C_0)) = e'(e(C_0)) = e'(D_0)$</p>
<p>Mà ta cũng có $D_1$ là <code>1-valent</code>, $D_0$ là <code>0-valent</code> =&gt; vô lý</p>
<p>![](<a href="https://i.imgur.com/dvbaKip.png">https://i.imgur.com/dvbaKip.png</a> =350x)</p>
<p><strong>Trường hợp 2</strong>: Nếu <code>p = p'</code></p>
<p>Xem xét một <code>Deciding Run</code> bất kỳ từ $C_0$, trong đó <code>p</code> không tham gia bất cứ <code>Step</code> nào.</p>
<p>Gọi $\sigma$ là Schedule tương ứng với <code>Deciding Run</code> đó.</p>
<p>Gọi $A = \sigma(C_0)$.</p>
<p>Theo bổ đề 1, $\sigma$ cũng có thể apply cho $D_i$: $E_i = \sigma(D_i)$.</p>
<p>Do $D_i$ là <code>i-valent</code> nên $E_i$ cũng là <code>i-valent</code>.</p>
<p>Cũng theo bổ đề 1 ta có:</p>
<ul>
<li>
<p>$e(A) = e(\sigma(C_0)) = \sigma(e(C_0)) = \sigma(D_0)$ = <code>0-valent</code> (1)</p>
</li>
<li>
<p>$e(e'(A)) = e(e'(\sigma(C_0))) = \sigma(e(e'(C_0))) = \sigma(e(C_1)) = \sigma(D_1)$ = <code>1-valent</code> (2)</p>
</li>
</ul>
<p>Từ (1) và (2), ta thấy điều này là vô lý vì trái với giả thiết A là một <code>Deciding Run</code>.</p>
<p>![](<a href="https://i.imgur.com/6EUMXi3.png">https://i.imgur.com/6EUMXi3.png</a> =550x)</p>
<p>Do vậy, bất kể trường hợp nào ta cũng suy ra vô lý dpcm.</p>
<h3 id="chứng-minh-mệnh-đề">
  Chứng minh mệnh đề
  <a class="heading-link" href="#ch%e1%bb%a9ng-minh-m%e1%bb%87nh-%c4%91%e1%bb%81">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<p>Ta nhận thấy rằng với một <code>deciding run</code> bất kỳ từ một <code>bivalent</code> configuration, chắc chắn phải tồn tại một <code>step</code> mà một <code>bivalent</code> configuration sẽ được chuyển thành một <code>univalent</code> configuration. Và <code>step</code> đó sẽ xác định giá trị cuối cùng mà các process đồng thuận với nhau. Điều ta cần chỉ ra ở đây là luôn tồn tại một cái <code>run</code> mà có thể tránh được sự chuyển giao này, từ đó tồn tại một <code>admissible</code> nhưng không <code>deciding</code> run.</p>
<p>Chúng ta sẽ xây dựng cái <code>admissible non-deciding run</code> đấy như sau:</p>
<ul>
<li>tạo một cái <code>priority queue</code> cho mọi process trong <code>P</code>
<ul>
<li>được sắp xếp theo thứ tự thời gian của các message được gửi tới nó trong MB.</li>
<li>Điều này làm cho tất cả các message đều sẽ lần lượt được nhận</li>
</ul>
</li>
<li>Chúng ta sẽ bắt đầu với một <code>bivalent</code> configuration $C_0$ (tồn tại theo bổ đề 2)</li>
<li>Chọn <code>e = (p,m)</code> là mesage được gửi sớm nhất trong <code>message buffer</code></li>
<li>Theo bổ đề 2, thì tồn tại một <code>bivalent</code> $C_1$ có thể reachable từ $C_0$ mà <code>e</code> là event được apply cuối cùng.</li>
<li>Tương tự ta có thể lặp lại các bước kể trên, để tạo thành một <code>admissible run</code> mà không bao giờ dừng.</li>
</ul>
<p>dpcm</p>

  </article>
</section>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"
    integrity="sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs" crossorigin="anonymous">
  
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"
    integrity="sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js"
    integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"
    onload="renderMathInElement(document.body,
      {
        delimiters: [
          {left: '$$', right: '$$', display:true},
          {left: '$', right: '$', display:false},
          {left: '\\(', right: '\\)', display: false},
          {left: '\\[', right: '\\]', display: true}
        ]
      }
    );"></script>

      </div>

      <footer class="footer">
  <section class="container">
    ©
    
    2022
     Thanh Le 
    ·
    Powered by <a href="https://gohugo.io/">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/">Coder</a>.
    
  </section>
</footer>

    </main>

    
      
      <script src="/js/coder.min.39a51230dce2ac866c049b52573e38bf60666af4bc63c1bdf203b9b2d95b1cd6.js" integrity="sha256-OaUSMNzirIZsBJtSVz44v2BmavS8Y8G98gO5stlbHNY="></script>
    

    

    

    

    

    

    

    

    
  </body>

</html>
